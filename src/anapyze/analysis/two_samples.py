import os
from os.path import exists, join
import numpy as np
import nibabel as nib
import shutil
import subprocess
import pandas as pd
import statsmodels.api as sm
from anapyze.io import spm
from anapyze.io import cat12
from anapyze.core import processor
from anapyze.core import utils
from scipy.stats import ttest_ind

def run_2sample_ttest_spm(spm_path,save_dir,
        group1: list,
        group2: list,
        group1_ages: list,
        group2_ages: list,
        covar2_name = False,
        group1_covar2 = False,
        group2_covar2 = False,
        mask: str = False,
        contrast_name: str = "contrast",
        contrast: str = "[1 -1 0]",
        ):
    """
    Executes a two-sample voxel-wise t-test in SPM via MATLAB, computes Cohen’s d maps,
    and estimates FDR-corrected thresholds for Cohen’s d.

    The function performs the following steps:
      1. Creates a fresh output directory (`save_dir`).
      2. Generates an SPM batch script (`model.m`) for a two-sample t-test with age covariate
         (and an optional second covariate), then runs it in MATLAB.
      3. Generates and runs the SPM “estimate model” batch (`estimate.m`).
      4. Generates and runs the SPM “contrast” batch (`results.m`) for the specified contrast.
      5. Converts the resulting t-value map (`spmT_0001.nii`) to a Cohen’s d map (`cohens_d.nii`).
      6. Calculates FDR-corrected thresholds for Cohen’s d based on the t-map and prints them.

    Parameters
    ----------
    spm_path : str
        Path to the SPM MATLAB script or SPM installation directory (as required by your setup).
        This is passed to the SPM batch generation functions to locate SPM in MATLAB.
    save_dir : str
        Directory where all intermediate and output files will be saved. If it exists,
        it will be deleted and recreated.
    group1 : list[str]
        List of file paths for the first group of subject images.
    group2 : list[str]
        List of file paths for the second group of subject images.
    group1_ages : list[float]
        List of age values (covariate 1) for subjects in `group1`, in the same order as `group1`.
    group2_ages : list[float]
        List of age values (covariate 1) for subjects in `group2`, in the same order as `group2`.
    covar2_name : str or False, default False
        Name of an optional second covariate (e.g., "Gender" or "Education"). If False, no second
        covariate is included.
    group1_covar2 : list[float] or False, default False
        Values of the second covariate for subjects in `group1`. Must match `covar2_name` if provided.
        Set to False if `covar2_name` is False.
    group2_covar2 : list[float] or False, default False
        Values of the second covariate for subjects in `group2`. Must match `covar2_name` if provided.
        Set to False if `covar2_name` is False.
    mask : str or False, default False
        File path to a binary mask image (`.nii`) that restricts the analysis to voxels where
        `mask != 0`. If False, no mask is applied.
    contrast_name : str, default "contrast"
        Name to assign to the contrast in the SPM batch (used when generating the contrast script).
    contrast : str, default "[1 -1 0 0]"
        Contrast vector in SPM format. The length must match the number of regressors in the model.
        For example, "[1 -1 0 0]" compares group1 > group2 while controlling for covariates.

    Returns
    -------
    None

    Notes
    -----
    After execution, the following files will appear in `save_dir`:
      - `model.m`: MATLAB script defining the two-sample t-test design and covariates.
      - `SPM.mat`: SPM design matrix file generated by the model batch.
      - `estimate.m`: MATLAB script to estimate the model parameters.
      - `results.m`: MATLAB script to compute the specified contrast.
      - `spmT_0001.nii`: Voxel-wise t-value map for the contrast.
      - `cohens_d.nii`: Voxel-wise Cohen’s d map, derived from `spmT_0001.nii`.

    Additionally, the function prints the FDR‐corrected threshold for t-values and the corresponding
    Cohen’s d threshold (computed via `utils.get_fdr_thresholds_from_spmt`) to the console.
    """

    if exists(save_dir):
        shutil.rmtree(save_dir)

    os.makedirs(save_dir)

    print("Creating SPM model....")

    mfile_model = join(save_dir, "model.m")

    spm.generate_mfile_model(spm_path, mfile_model, save_dir, group1, group2,
                         covar1_name='Age', group1_covar1=group1_ages, group2_covar1=group2_ages,
                         covar2_name=covar2_name, group1_covar2=group1_covar2, group2_covar2=group2_covar2,
                         mask=mask)

    processor.run_matlab_command(mfile_model)

    print("Estimating model....")

    mfile_estimate = join(save_dir, "estimate.m")
    spm_mat = join(save_dir, "SPM.mat")

    spm.generate_mfile_estimate_model(spm_path,mfile_estimate,spm_mat)

    processor.run_matlab_command(mfile_estimate)

    print("Calculating results....")

    mfile_results = join(save_dir, "results.m")
    spm_mat = join(save_dir, "SPM.mat")

    spm.generate_mfile_contrast(spm_path, mfile_results, spm_mat, contrast_name = contrast_name, contrast = contrast)
    processor.run_matlab_command(mfile_results)

    print("Converting results to Cohens d....")

    out_t_values = join(save_dir, "spmT_0001.nii")
    out_cohens = join(save_dir, "cohens_d.nii")

    utils.spm_map_2_cohens_d(out_t_values, out_cohens, len_1 = len(group1), len_2 = len(group2))

    print("Calculating thresholds for Cohens d (FDR corrected ....")
    t_thres, cohens_d_thres = utils.get_fdr_thresholds_from_spmt(out_t_values, n1 = len(group1), n2 = len(group2))
    print(t_thres,cohens_d_thres)

def run_2sample_ttest_cat12_new_tiv_model(spm_path, save_dir,
        group1: list,
        group2: list,
        group1_ages: list,
        group2_ages: list,
        group1_tivs: list,
        group2_tivs: list,
        mask: str = False,
        contrast_name: str = "contrast",
        contrast: str = "[1 -1 0 0]",
        ):
    """
    Executes a two-sample voxel-wise t-test in SPM using the CAT12 New TIV model, computes
    Cohen’s d maps, and estimates FDR-corrected thresholds for Cohen’s d.

    This function performs the following steps:
      1. Creates (or recreates) the output directory (`save_dir`).
      2. Generates an SPM batch script (`model_cat12.m`) using CAT12’s New TIV model with
         age and total intracranial volume (TIV) as covariates, then runs it in MATLAB.
      3. Generates and runs the SPM “estimate model” batch (`estimate.m`).
      4. Generates and runs the SPM “contrast” batch (`results.m`) for the specified contrast.
      5. Converts the resulting t-value map (`spmT_0001.nii`) to a Cohen’s d map (`cohens_d.nii`).
      6. Calculates FDR-corrected thresholds for the t-map and corresponding Cohen’s d,
         and prints these thresholds to the console.

    Parameters
    ----------
    spm_path : str
        Path to the SPM MATLAB script or installation directory (as required by your setup).
        Used by both CAT12 and SPM batch generators to locate SPM in MATLAB.
    save_dir : str
        Directory where all intermediate and output files will be saved. If it already exists,
        it will be deleted and recreated.
    group1 : list[str]
        List of file paths for the first group of subject images (e.g., segmented gray matter volumes).
    group2 : list[str]
        List of file paths for the second group of subject images.
    group1_ages : list[float]
        List of age values (covariate 1) for subjects in `group1`, in the same order.
    group2_ages : list[float]
        List of age values (covariate 1) for subjects in `group2`, in the same order.
    group1_tivs : list[float]
        List of total intracranial volume (TIV) values (covariate 2) for subjects in `group1`.
    group2_tivs : list[float]
        List of TIV values (covariate 2) for subjects in `group2`.
    mask : str or False, default False
        File path to a binary mask image (`.nii`) restricting analysis to voxels where
        `mask != 0`. If False, no mask is applied.
    contrast_name : str, default "contrast"
        Name to assign to the contrast when generating the contrast batch script.
    contrast : str, default "[1 -1 0 0]"
        Contrast vector in SPM format. Its length must match the number of regressors in the model
        (including covariates).

    Returns
    -------
    None
        Results are written to files in `save_dir`:
          - `model_cat12.m`: MATLAB script defining the CAT12 New TIV two-sample design.
          - `SPM.mat`: SPM design matrix produced by the model batch.
          - `estimate.m`: MATLAB script to estimate the model parameters.
          - `results.m`: MATLAB script to compute the specified contrast.
          - `spmT_0001.nii`: Voxel-wise t-value map for the contrast.
          - `cohens_d.nii`: Voxel-wise Cohen’s d map derived from the t-map.
        Additionally, FDR‐corrected thresholds for both t-values and Cohen’s d are printed.
    """

    if exists(save_dir):
        shutil.rmtree(save_dir)

    os.makedirs(save_dir)

    print("Creating SPM model....")

    mfile_model = join(save_dir, "model_cat12.m")

    cat12.generate_mfile_model(spm_path, save_dir, group1, group1_ages, group1_tivs,
                               group2,group2_ages, group2_tivs, mask)

    processor.run_matlab_command(mfile_model)

    print("Estimating model....")

    mfile_estimate = join(save_dir, "estimate.m")
    spm_mat = join(save_dir, "SPM.mat")

    spm.generate_mfile_estimate_model(mfile_estimate, spm_mat)

    processor.run_matlab_command(mfile_model)

    print("Calculating results....")

    mfile_results = join(save_dir, "results.m")
    spm_mat = join(save_dir, "SPM.mat")

    spm.generate_mfile_contrast(spm_path, mfile_results, spm_mat, contrast_name = contrast_name, contrast = contrast)
    processor.run_matlab_command(mfile_model)

    print("Converting results to Cohens d....")

    out_t_values = join(save_dir, "spmT_0001.nii")
    out_cohens = join(save_dir, "cohens_d.nii")

    utils.spm_map_2_cohens_d(out_t_values, out_cohens, len_1 = len(group1), len_2 = len(group2))

    print("Calculating thresholds for Cohens d (FDR corrected ....")
    t_thres, cohens_d_thres = utils.get_fdr_thresholds_from_spmt(out_t_values, n1 = len(group1), n2 = len(group2))
    print(t_thres,cohens_d_thres)

def run_2sample_ttest_atlas(group1: list, group2: list, atlas_path, output_path, operation = "mean"):

    atlas_img = nib.load(atlas_path)
    atlas_data = atlas_img.get_fdata()

    result = atlas_data * 0
    p_vals = atlas_data * 0

    # Get the unique values of the atlas, which correspond to the ROIs
    rois = np.unique(atlas_data)
    
    # Loop over the ROIs
    for i in rois:
        if i != 0:
            # Get the indices of the voxels that belong to the current ROI
            indx = np.where(atlas_data == i)
            
            group_1_vals = []
            
            for image in group1:
                img_ = nib.load(image)
                img_data = img_.get_fdata()
                if operation == "mean":
                    val = np.mean(img_data[indx])
                if operation == "sum":
                    val = np.sum(img_data[indx])
                group_1_vals.append(val)
            
            group_2_vals = []
            
            for image in group2:
                img_ = nib.load(image)
                img_data = img_.get_fdata()
                if operation == "mean":
                    val = np.mean(img_data[indx])
                if operation == "sum":
                    val = np.sum(img_data[indx])
                group_2_vals.append(val)
        
            t_stat, p_val = ttest_ind(group_1_vals, group_2_vals, equal_var=True)
            cohens_d = t_stat*(np.sqrt(1 / len(group_1_vals) + 1 / len(group_2_vals)))

            result[indx] =  cohens_d
            p_vals[indx] = p_val
    
    results_img = nib.Nifti1Image(result,atlas_img.affine, atlas_img.header)
    nib.save(results_img,join(output_path,'cohens_d.nii'))

    pvals_img = nib.Nifti1Image(p_vals,atlas_img.affine, atlas_img.header)
    nib.save(pvals_img,join(output_path,'p_values.nii'))


def run_2sample_anova_with_covariate_atlas(group1, group2, group1_covar, group2_covar, atlas_path, output_path, operation="mean"):
  
    atlas_img = nib.load(atlas_path)
    atlas_data = atlas_img.get_fdata()

    d_vals = np.zeros_like(atlas_data)
    f_stats = np.zeros_like(atlas_data)
    p_vals = np.ones_like(atlas_data)

    rois = np.unique(atlas_data)
    rois = rois[rois != 0]
    
    all_imgs = group1 + group2
    all_covars = group1_covar + group2_covar
    all_groups = [0] * len(group1) + [1] * len(group2)


    n1 = len(group1)
    n2 = len(group2)

    for roi in rois:
        mask = atlas_data == roi
        roi_vals = []

        for img_path in all_imgs:
            data = nib.load(img_path).get_fdata()
            val = np.mean(data[mask]) if operation == "mean" else np.sum(data[mask])
            roi_vals.append(val)

        df = pd.DataFrame({
            "value": roi_vals,
            "Group": all_groups, 
            "age": all_covars
        })

        df['Group'] = df['Group'].astype('category')
        X = sm.add_constant(pd.get_dummies(df[["Group", "age"]], drop_first=True))
        model = sm.OLS(df["value"], X).fit()
        f_test = model.f_test("Group[T.1]")

        f_val = f_test.fvalue.item()
        d_val = np.sqrt(f_val * (n1 + n2) / (n1 * n2)) if f_val > 0 else 0.0

        f_stats[mask] = f_val
        d_vals[mask] = d_val
        p_vals[mask] = f_test.pvalue.item()

    nib.save(nib.Nifti1Image(f_stats, atlas_img.affine, atlas_img.header), os.path.join(output_path, "f_stat_group.nii"))
    nib.save(nib.Nifti1Image(d_vals, atlas_img.affine, atlas_img.header), os.path.join(output_path, "cohens_d_group.nii"))
    nib.save(nib.Nifti1Image(p_vals, atlas_img.affine, atlas_img.header), os.path.join(output_path, "p_values_group.nii"))
